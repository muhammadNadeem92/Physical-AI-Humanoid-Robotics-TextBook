"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[642],{8453(n,e,i){i.d(e,{R:()=>r,x:()=>a});var o=i(6540);const t={},s=o.createContext(t);function r(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),o.createElement(s.Provider,{value:e},n.children)}},9941(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-04-digital-twin/gazebo-ros2","title":"Chapter 2: Gazebo Simulation with ROS 2","description":"Introduction","source":"@site/docs/module-04-digital-twin/gazebo-ros2.md","sourceDirName":"module-04-digital-twin","slug":"/module-04-digital-twin/gazebo-ros2","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-04-digital-twin/gazebo-ros2","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadNadeem92/Physical-AI-Humanoid-Robotics-TextBook/tree/main/docs/module-04-digital-twin/gazebo-ros2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Digital Twins & Simulation Concepts","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-04-digital-twin/digital-twin-concepts"},"next":{"title":"Chapter 3: Unity for Visualization & Human\u2013Robot Interaction","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-04-digital-twin/unity-hri"}}');var t=i(4848),s=i(8453);const r={},a="Chapter 2: Gazebo Simulation with ROS 2",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"Physics Engine Configuration",id:"physics-engine-configuration",level:3},{value:"ROS 2 + Gazebo Bridges",id:"ros-2--gazebo-bridges",level:3},{value:"Simulated Sensors and Actuators",id:"simulated-sensors-and-actuators",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: Launching a Humanoid Proxy in Gazebo",id:"example-launching-a-humanoid-proxy-in-gazebo",level:3},{value:"Example: Controlling Joints Using ROS 2 Topics",id:"example-controlling-joints-using-ros-2-topics",level:3},{value:"Example: Visualizing Sensor Output in RViz",id:"example-visualizing-sensor-output-in-rviz",level:3},{value:"Summary &amp; Key Takeaways",id:"summary--key-takeaways",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-2-gazebo-simulation-with-ros-2",children:"Chapter 2: Gazebo Simulation with ROS 2"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"In Chapter 1, you learned about digital twin concepts and their importance in humanoid robotics. Now we'll explore how to implement these concepts using Gazebo, the primary physics-based simulation environment for robotics. Gazebo provides realistic physics simulation, sensor modeling, and environment representation that makes it ideal for creating digital twins of humanoid robots."}),"\n",(0,t.jsx)(e.p,{children:"Gazebo is widely used in the robotics community because of its excellent integration with ROS 2, realistic physics engines (ODE, Bullet, and DART), and comprehensive sensor simulation capabilities. When combined with ROS 2, Gazebo enables you to create complete digital twin environments where you can test control algorithms, sensor processing, and robot behaviors in a safe, virtual setting."}),"\n",(0,t.jsx)(e.p,{children:"This chapter builds on the digital twin concepts you learned in Chapter 1 and shows you how to create practical simulation environments using Gazebo with ROS 2 integration. You'll learn about Gazebo's architecture, how to configure physics engines, and how to connect simulated sensors to ROS 2 topics for realistic testing."}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you'll be able to launch humanoid robot models in Gazebo, configure physics parameters, connect simulated sensors to ROS 2, and control robot joints using ROS 2 nodes. You'll also learn how to visualize sensor output in RViz to validate your simulation setup."}),"\n",(0,t.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo's architecture consists of several key components that work together to create realistic simulation environments:"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Gazebo Server"}),": The core physics simulation engine that handles physics calculations, collision detection, and sensor simulation. It runs in the background and can be controlled through various interfaces."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Gazebo Client"}),": The graphical user interface that allows you to visualize the simulation, inspect robot states, and interact with the environment. Multiple clients can connect to the same server."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Model Database"}),": A collection of pre-built robot models, objects, and environments that can be easily incorporated into simulations. This includes humanoid robots, sensors, and common objects."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Plugin System"}),": Gazebo's extensible architecture allows custom plugins for sensors, controllers, and other functionality. This is how ROS 2 integration is achieved."]}),"\n",(0,t.jsx)(e.h3,{id:"physics-engine-configuration",children:"Physics Engine Configuration"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo supports multiple physics engines, each with different strengths:"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": The most commonly used engine, optimized for rigid body dynamics. It's stable and well-tested, making it ideal for most humanoid robotics applications."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Bullet"}),": Offers more advanced contact handling and is better for complex collision scenarios. It's particularly useful when simulating interactions with deformable objects."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"DART (Dynamic Animation and Robotics Toolkit)"}),": Provides advanced features for articulated body simulation and is excellent for complex humanoid models."]}),"\n",(0,t.jsx)(e.p,{children:"Configuration parameters include:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gravity"}),": Typically set to -9.8 m/s\xb2 for Earth-like conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real Time Factor (RTF)"}),": Controls simulation speed relative to real time"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Max Step Size"}),": Determines physics update frequency"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Solver Iterations"}),": Affects physics stability and accuracy"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"ros-2--gazebo-bridges",children:"ROS 2 + Gazebo Bridges"}),"\n",(0,t.jsx)(e.p,{children:"The integration between ROS 2 and Gazebo is facilitated through several bridge components:"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"gazebo_ros_pkgs"}),": A collection of ROS 2 packages that provide the interface between ROS 2 and Gazebo. These include plugins for spawning robots, publishing sensor data, and controlling joints."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Robot State Publisher"}),": Publishes joint states and transforms that allow RViz to visualize the robot correctly in the simulation."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Sensor Bridges"}),": Convert Gazebo sensor data to ROS 2 messages (sensor_msgs) for processing by ROS 2 nodes."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Controller Bridges"}),": Allow ROS 2 controllers to send commands to simulated joints in Gazebo."]}),"\n",(0,t.jsx)(e.h3,{id:"simulated-sensors-and-actuators",children:"Simulated Sensors and Actuators"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo provides realistic simulation of various sensors and actuators:"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Camera Sensors"}),": Simulate RGB, depth, and stereo cameras with realistic noise and distortion models."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"IMU Sensors"}),": Model inertial measurement units with configurable noise parameters and bias drift."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Force/Torque Sensors"}),": Simulate force and torque measurements at joints and end-effectors."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"LIDAR and Range Sensors"}),": Model various types of distance sensors with realistic beam patterns and noise."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Joint Actuators"}),": Simulate motor dynamics, including position, velocity, and effort control with realistic response characteristics."]}),"\n",(0,t.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(e.h3,{id:"example-launching-a-humanoid-proxy-in-gazebo",children:"Example: Launching a Humanoid Proxy in Gazebo"}),"\n",(0,t.jsx)(e.p,{children:"Here's how to launch a humanoid robot model in Gazebo with ROS 2 integration:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"\x3c!-- launch_humanoid_gazebo.launch.py --\x3e\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Declare launch arguments\r\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\r\n    robot_name = LaunchConfiguration('robot_name', default='humanoid_robot')\r\n\r\n    # Include Gazebo launch\r\n    gazebo = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource([\r\n            PathJoinSubstitution([\r\n                FindPackageShare('gazebo_ros'),\r\n                'launch',\r\n                'gazebo.launch.py'\r\n            ])\r\n        ])\r\n    )\r\n\r\n    # Spawn robot in Gazebo\r\n    spawn_entity = Node(\r\n        package='gazebo_ros',\r\n        executable='spawn_entity.py',\r\n        arguments=[\r\n            '-topic', 'robot_description',\r\n            '-entity', robot_name,\r\n            '-x', '0', '-y', '0', '-z', '1.0'\r\n        ],\r\n        output='screen'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        DeclareLaunchArgument(\r\n            'use_sim_time',\r\n            default_value='true',\r\n            description='Use simulation (Gazebo) clock if true'\r\n        ),\r\n        gazebo,\r\n        spawn_entity\r\n    ])\n"})}),"\n",(0,t.jsx)(e.h3,{id:"example-controlling-joints-using-ros-2-topics",children:"Example: Controlling Joints Using ROS 2 Topics"}),"\n",(0,t.jsx)(e.p,{children:"Once your humanoid robot is in Gazebo, you can control its joints using ROS 2 topics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n# joint_controller_example.py\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float64MultiArray\r\nimport math\r\nimport time\r\n\r\nclass JointController(Node):\r\n    def __init__(self):\r\n        super().__init__('joint_controller')\r\n\r\n        # Publisher for joint commands\r\n        self.joint_pub = self.create_publisher(\r\n            Float64MultiArray,\r\n            '/joint_group_position_controller/commands',\r\n            10\r\n        )\r\n\r\n        # Timer to send commands at 50Hz\r\n        self.timer = self.create_timer(0.02, self.send_joint_commands)\r\n        self.time_counter = 0.0\r\n\r\n    def send_joint_commands(self):\r\n        msg = Float64MultiArray()\r\n\r\n        # Create oscillating joint commands for demonstration\r\n        joint_positions = []\r\n        for i in range(6):  # Example: 6 joints\r\n            position = 0.5 * math.sin(self.time_counter + i * 0.5)\r\n            joint_positions.append(position)\r\n\r\n        msg.data = joint_positions\r\n        self.joint_pub.publish(msg)\r\n        self.time_counter += 0.02\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = JointController()\r\n\r\n    try:\r\n        rclpy.spin(controller)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        controller.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"example-visualizing-sensor-output-in-rviz",children:"Example: Visualizing Sensor Output in RViz"}),"\n",(0,t.jsx)(e.p,{children:"To visualize sensor data from your simulated robot in RViz:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# config/sensor_visualization.rviz\r\nPanels:\r\n  - Class: rviz_common/Displays\r\n    Name: Displays\r\n  - Class: rviz_common/Views\r\n    Name: Views\r\n\r\nVisualization Manager:\r\n  Displays:\r\n    - Class: rviz_default_plugins/RobotModel\r\n      Name: RobotModel\r\n      Topic: /robot_description\r\n    - Class: rviz_default_plugins/Image\r\n      Name: CameraFeed\r\n      Topic: /camera/image_raw\r\n    - Class: rviz_default_plugins/PointCloud2\r\n      Name: PointCloud\r\n      Topic: /lidar/points\r\n    - Class: rviz_default_plugins/TF\r\n      Name: TF\r\n      Show Arrows: true\r\n      Show Names: true\r\n\r\nGlobal Options:\r\n  Fixed Frame: odom\r\n  Frame Rate: 30\n"})}),"\n",(0,t.jsx)(e.h2,{id:"summary--key-takeaways",children:"Summary & Key Takeaways"}),"\n",(0,t.jsx)(e.p,{children:"In this chapter, you've learned how to implement digital twin concepts using Gazebo simulation with ROS 2 integration:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo architecture"})," includes server, client, model database, and plugin system components that work together to create realistic simulations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics engine configuration"})," allows you to tune simulation parameters for different use cases and accuracy requirements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2 bridges"})," connect Gazebo to the ROS 2 ecosystem, enabling seamless integration of simulated and real-world components"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simulated sensors and actuators"})," provide realistic modeling of physical hardware for comprehensive testing"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"You've seen practical examples of launching humanoid robots in Gazebo, controlling joints through ROS 2 topics, and visualizing sensor output in RViz. These capabilities form the foundation for creating comprehensive digital twin environments that enable safe, effective testing of humanoid robot behaviors."}),"\n",(0,t.jsx)(e.p,{children:"In the next chapter, we'll explore Unity as an alternative simulation environment focused on advanced visualization and human-robot interaction, complementing the physics-focused approach of Gazebo."})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);