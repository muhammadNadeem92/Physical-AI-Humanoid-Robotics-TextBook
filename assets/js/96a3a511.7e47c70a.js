"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[470],{4759(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-06-vla-systems/action-safety","title":"Chapter 4: Action Execution & Safety","description":"Introduction","source":"@site/docs/module-06-vla-systems/action-safety.md","sourceDirName":"module-06-vla-systems","slug":"/module-06-vla-systems/action-safety","permalink":"/docs/module-06-vla-systems/action-safety","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadNadeem92/physical-ai-humanoid-robotics-textbook/tree/main/docs/module-06-vla-systems/action-safety.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Cognitive Planning with LLMs","permalink":"/docs/module-06-vla-systems/llm-planning"},"next":{"title":"Chapter 1: Humanoid Kinematics & Dynamics","permalink":"/docs/module-07-humanoid-hri/kinematics-dynamics"}}');var a=r(4848),i=r(8453);const s={},o="Chapter 4: Action Execution & Safety",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Mapping Plans to ROS 2 Actions",id:"mapping-plans-to-ros-2-actions",level:3},{value:"Action Monitoring &amp; Feedback",id:"action-monitoring--feedback",level:3},{value:"Failure Recovery Strategies",id:"failure-recovery-strategies",level:3},{value:"Safety Boundaries in Embodied LLMs",id:"safety-boundaries-in-embodied-llms",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: Plan \u2192 ROS 2 Action Graph",id:"example-plan--ros-2-action-graph",level:3},{value:"Example: Detect Failure (Object Not Found) and Re-plan",id:"example-detect-failure-object-not-found-and-re-plan",level:3},{value:"Example: Safety Boundary Implementation",id:"example-safety-boundary-implementation",level:3},{value:"Summary &amp; Key Takeaways",id:"summary--key-takeaways",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chapter-4-action-execution--safety",children:"Chapter 4: Action Execution & Safety"})}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"In the previous chapter, you learned about cognitive planning with LLMs and how to convert high-level commands into detailed step-by-step execution plans with proper constraint enforcement. Now we'll explore how to safely execute these plans in the physical world through ROS 2 actions with monitoring and failure recovery."}),"\n",(0,a.jsx)(n.p,{children:"Action execution in VLA systems requires careful attention to safety boundaries, as the plans generated by LLMs must be executed in the real world where physical constraints and uncertainties can lead to failures. This chapter covers mapping plans to ROS 2 actions, action monitoring and feedback, failure recovery strategies, and safety boundaries in embodied LLM systems."}),"\n",(0,a.jsx)(n.p,{children:"This chapter emphasizes the critical importance of safety in VLA systems, where natural language commands can result in physical robot actions. You'll learn how to implement robust execution systems that can detect failures, re-plan when necessary, and ask for clarification when encountering unexpected situations."}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, you'll understand how to safely execute VLA system plans in the physical world while maintaining the safety boundaries that protect both the robot and its environment."}),"\n",(0,a.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"mapping-plans-to-ros-2-actions",children:"Mapping Plans to ROS 2 Actions"}),"\n",(0,a.jsx)(n.p,{children:"Mapping high-level plans to ROS 2 actions involves translating abstract plan steps into concrete ROS 2 action executions:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Action Interface Mapping"}),": Converting plan step parameters into appropriate ROS 2 action goal messages with proper type definitions and validation."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Execution Context"}),": Maintaining context information that allows ROS 2 action servers to execute actions with awareness of the overall plan and current state."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Parameter Validation"}),": Validating action parameters before sending goals to ensure they meet ROS 2 message type requirements and safety constraints."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Result Processing"}),": Converting ROS 2 action results back into plan execution context for monitoring and potential re-planning."]}),"\n",(0,a.jsx)(n.h3,{id:"action-monitoring--feedback",children:"Action Monitoring & Feedback"}),"\n",(0,a.jsx)(n.p,{children:"Action monitoring ensures that plan execution proceeds as expected and detects deviations or failures:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Progress Tracking"}),": Monitoring action execution progress and comparing it against expected timelines and intermediate states."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Success Criteria"}),": Defining clear success criteria for each action that can be objectively evaluated by monitoring systems."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Anomaly Detection"}),": Identifying unexpected behaviors or deviations from expected execution patterns that may indicate problems."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"State Synchronization"}),": Keeping the planning system's understanding of the world synchronized with the actual state as actions are executed."]}),"\n",(0,a.jsx)(n.h3,{id:"failure-recovery-strategies",children:"Failure Recovery Strategies"}),"\n",(0,a.jsx)(n.p,{children:"Failure recovery strategies handle situations where actions do not execute as planned:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Graceful Degradation"}),": Implementing fallback behaviors that maintain system safety when primary actions fail."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Re-planning"}),": Detecting when the current plan cannot be executed and triggering the planning system to generate alternative approaches."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Clarification Requests"}),": Asking for human input when the system encounters ambiguous or unclear situations during execution."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Error Isolation"}),": Isolating the impact of individual action failures to prevent cascading failures in the overall plan."]}),"\n",(0,a.jsx)(n.h3,{id:"safety-boundaries-in-embodied-llms",children:"Safety Boundaries in Embodied LLMs"}),"\n",(0,a.jsx)(n.p,{children:"Safety boundaries ensure that LLM-generated plans are executed safely in the physical world:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Physical Constraints"}),": Ensuring actions respect physical limits like joint angles, payload capacities, and workspace boundaries."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Environmental Safety"}),": Implementing checks to prevent actions that could harm humans, objects, or the environment."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Temporal Safety"}),": Managing execution timing to prevent dangerous situations like collisions or unstable robot configurations."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Validation Gates"}),": Multiple safety checks before, during, and after action execution to ensure safe operation."]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-plan--ros-2-action-graph",children:"Example: Plan \u2192 ROS 2 Action Graph"}),"\n",(0,a.jsx)(n.p,{children:"Converting a validated plan into a ROS 2 action execution graph:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'# ROS 2 Action Graph Configuration\r\naction_graph:\r\n  name: "pick_up_bottle_from_table"\r\n  nodes:\r\n    - id: "approach_table"\r\n      action_type: "move_base_msgs/MoveBaseAction"\r\n      goal:\r\n        target_pose:\r\n          header:\r\n            frame_id: "map"\r\n          pose:\r\n            position: {x: 1.0, y: 0.5, z: 0.0}\r\n            orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}\r\n      dependencies: []\r\n      timeout: 30.0\r\n      retry_policy:\r\n        max_retries: 3\r\n        backoff_factor: 1.5\r\n\r\n    - id: "perceive_environment"\r\n      action_type: "object_recognition_msgs/ObjectRecognitionAction"\r\n      goal:\r\n        object_type: "bottle"\r\n        search_area:\r\n          center: {x: 1.0, y: 0.5, z: 0.8}\r\n          size: {x: 0.5, y: 0.5, z: 0.5}\r\n      dependencies: ["approach_table"]\r\n      timeout: 10.0\r\n\r\n    - id: "plan_grasp"\r\n      action_type: "grasp_planning_msgs/GraspPlanningAction"\r\n      goal:\r\n        object_id: "detected_bottle"\r\n        grasp_type: "top_grasp"\r\n      dependencies: ["perceive_environment"]\r\n      timeout: 15.0\r\n\r\n    - id: "execute_grasp"\r\n      action_type: "manipulation_msgs/PickupAction"\r\n      goal:\r\n        grasp_plan: "computed_grasp"\r\n        object_id: "detected_bottle"\r\n      dependencies: ["plan_grasp"]\r\n      timeout: 20.0\r\n      safety_constraints:\r\n        - max_force: 50.0  # Newtons\r\n        - collision_check: true\r\n        - force_feedback_monitoring: true\r\n\r\n    - id: "lift_object"\r\n      action_type: "control_msgs/FollowJointTrajectoryAction"\r\n      goal:\r\n        trajectory:\r\n          joint_names: ["arm_joint_1", "arm_joint_2", "arm_joint_3"]\r\n          points:\r\n            - positions: [0.1, 0.2, 0.3]\r\n              time_from_start: {sec: 2, nanosec: 0}\r\n      dependencies: ["execute_grasp"]\r\n      timeout: 10.0\r\n      safety_constraints:\r\n        - velocity_limits: true\r\n        - acceleration_limits: true\r\n\r\n  edges:\r\n    - from: "approach_table"\r\n      to: "perceive_environment"\r\n    - from: "perceive_environment"\r\n      to: "plan_grasp"\r\n    - from: "plan_grasp"\r\n      to: "execute_grasp"\r\n    - from: "execute_grasp"\r\n      to: "lift_object"\r\n\r\n  safety_boundaries:\r\n    - workspace_limits:\r\n        min: {x: -1.0, y: -1.0, z: 0.0}\r\n        max: {x: 2.0, y: 2.0, z: 2.0}\r\n    - joint_limits:\r\n        position: true\r\n        velocity: true\r\n        effort: true\r\n    - collision_avoidance: true\r\n    - human_safety_zone: 1.0  # meters\r\n\r\n  monitoring_config:\r\n    progress_check_interval: 1.0  # seconds\r\n    anomaly_detection:\r\n      enabled: true\r\n      thresholds:\r\n        execution_time_deviation: 2.0  # standard deviations\r\n        position_error: 0.1  # meters\r\n    feedback_frequency: 10.0  # Hz\n'})}),"\n",(0,a.jsx)(n.p,{children:"This configuration shows how a high-level plan is converted into a graph of ROS 2 actions with dependencies, safety constraints, and monitoring configurations."}),"\n",(0,a.jsx)(n.h3,{id:"example-detect-failure-object-not-found-and-re-plan",children:"Example: Detect Failure (Object Not Found) and Re-plan"}),"\n",(0,a.jsx)(n.p,{children:"Implementing failure detection and re-planning when an expected object is not found:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Example Python code for failure detection and re-planning\r\nimport rclpy\r\nfrom rclpy.action import ActionClient\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Pose\r\nfrom action_msgs.msg import GoalStatus\r\nfrom object_recognition_msgs.action import ObjectRecognition\r\nfrom manipulation_msgs.action import Pickup\r\nfrom std_srvs.srv import Trigger\r\nimport asyncio\r\nimport json\r\n\r\nclass VLAExecutionManager(Node):\r\n    def __init__(self):\r\n        super().__init__('vla_execution_manager')\r\n\r\n        # Action clients for different ROS 2 actions\r\n        self.object_recognition_client = ActionClient(\r\n            self, ObjectRecognition, 'recognize_objects')\r\n        self.pickup_client = ActionClient(\r\n            self, Pickup, 'pickup_object')\r\n\r\n        # Service client for re-planning\r\n        self.replan_client = self.create_client(\r\n            Trigger, 'replan_action')\r\n\r\n        # Publishers for monitoring and feedback\r\n        self.status_publisher = self.create_publisher(\r\n            String, 'vla_execution_status', 10)\r\n        self.feedback_publisher = self.create_publisher(\r\n            String, 'vla_execution_feedback', 10)\r\n\r\n        # Current plan and execution state\r\n        self.current_plan = None\r\n        self.current_step_index = 0\r\n        self.execution_state = 'idle'\r\n\r\n        self.get_logger().info('VLA Execution Manager initialized')\r\n\r\n    async def execute_plan(self, plan):\r\n        \"\"\"Execute a validated plan with monitoring and failure handling\"\"\"\r\n        self.current_plan = plan\r\n        self.current_step_index = 0\r\n        self.execution_state = 'executing'\r\n\r\n        self.publish_status('Starting plan execution')\r\n\r\n        for step_index, step in enumerate(plan['plan']):\r\n            self.current_step_index = step_index\r\n\r\n            execution_result = await self.execute_single_step(step)\r\n\r\n            if execution_result['status'] == 'success':\r\n                self.publish_feedback(f'Step {step[\"step_id\"]} completed successfully')\r\n                continue\r\n            elif execution_result['status'] == 'failure':\r\n                self.publish_status(f'Step {step[\"step_id\"]} failed: {execution_result[\"error\"]}')\r\n\r\n                # Handle specific failure types\r\n                if execution_result['failure_type'] == 'object_not_found':\r\n                    re_plan_result = await self.handle_object_not_found(step, plan)\r\n                    if re_plan_result['status'] == 'success':\r\n                        # Retry execution with new plan\r\n                        return await self.execute_plan(re_plan_result['new_plan'])\r\n                    else:\r\n                        self.publish_status('Re-planning failed, aborting execution')\r\n                        return {'status': 'aborted', 'reason': 'replanning_failed'}\r\n\r\n                elif execution_result['failure_type'] == 'grasp_failure':\r\n                    recovery_result = await self.handle_grasp_failure(step)\r\n                    if recovery_result['status'] == 'recovered':\r\n                        continue  # Continue with next step\r\n                    else:\r\n                        return {'status': 'failed', 'reason': 'grasp_failure_unrecoverable'}\r\n\r\n                else:\r\n                    self.publish_status(f'Unhandled failure: {execution_result[\"error\"]}')\r\n                    return {'status': 'failed', 'reason': execution_result['error']}\r\n\r\n        self.execution_state = 'completed'\r\n        self.publish_status('Plan execution completed successfully')\r\n        return {'status': 'success'}\r\n\r\n    async def execute_single_step(self, step):\r\n        \"\"\"Execute a single plan step and return result\"\"\"\r\n        try:\r\n            if step['action'] == 'perceive_environment':\r\n                return await self.execute_perception_step(step)\r\n            elif step['action'] == 'execute_grasp':\r\n                return await self.execute_grasp_step(step)\r\n            elif step['action'] == 'approach_location':\r\n                return await self.execute_approach_step(step)\r\n            else:\r\n                return {\r\n                    'status': 'failure',\r\n                    'error': f'Unknown action type: {step[\"action\"]}',\r\n                    'failure_type': 'unknown_action'\r\n                }\r\n        except Exception as e:\r\n            return {\r\n                'status': 'failure',\r\n                'error': str(e),\r\n                'failure_type': 'execution_error'\r\n            }\r\n\r\n    async def execute_perception_step(self, step):\r\n        \"\"\"Execute perception step and check for expected objects\"\"\"\r\n        self.get_logger().info(f'Executing perception step: {step[\"step_id\"]}')\r\n\r\n        # Wait for action server\r\n        self.object_recognition_client.wait_for_server()\r\n\r\n        # Create goal\r\n        goal_msg = ObjectRecognition.Goal()\r\n        goal_msg.object_type = step['parameters']['target_object']\r\n        goal_msg.search_area = self.create_search_area(\r\n            step['parameters']['search_area'])\r\n\r\n        # Send goal\r\n        goal_future = self.object_recognition_client.send_goal_async(goal_msg)\r\n        goal_handle = await goal_future\r\n\r\n        if not goal_handle.accepted:\r\n            return {\r\n                'status': 'failure',\r\n                'error': 'Goal rejected by server',\r\n                'failure_type': 'server_rejection'\r\n            }\r\n\r\n        # Get result\r\n        result_future = goal_handle.get_result_async()\r\n        result = await result_future\r\n\r\n        # Check if object was found\r\n        if result.result.found_objects and len(result.result.found_objects) > 0:\r\n            self.get_logger().info('Object found successfully')\r\n            return {'status': 'success'}\r\n        else:\r\n            self.get_logger().warn('Object not found in expected location')\r\n            return {\r\n                'status': 'failure',\r\n                'error': 'Target object not found',\r\n                'failure_type': 'object_not_found'\r\n            }\r\n\r\n    async def execute_grasp_step(self, step):\r\n        \"\"\"Execute grasp step with force feedback monitoring\"\"\"\r\n        self.get_logger().info(f'Executing grasp step: {step[\"step_id\"]}')\r\n\r\n        self.pickup_client.wait_for_server()\r\n\r\n        goal_msg = Pickup.Goal()\r\n        goal_msg.object_id = step['parameters']['object_id']\r\n        goal_msg.grasp_pose = self.create_grasp_pose(\r\n            step['parameters']['grasp_pose'])\r\n\r\n        goal_future = self.pickup_client.send_goal_async(goal_msg)\r\n        goal_handle = await goal_future\r\n\r\n        if not goal_handle.accepted:\r\n            return {\r\n                'status': 'failure',\r\n                'error': 'Grasp goal rejected',\r\n                'failure_type': 'grasp_rejection'\r\n            }\r\n\r\n        result_future = goal_handle.get_result_async()\r\n        result = await result_future\r\n\r\n        if result.result.success:\r\n            self.get_logger().info('Grasp completed successfully')\r\n            return {'status': 'success'}\r\n        else:\r\n            self.get_logger().warn(f'Grasp failed: {result.result.error_message}')\r\n            return {\r\n                'status': 'failure',\r\n                'error': result.result.error_message,\r\n                'failure_type': 'grasp_failure'\r\n            }\r\n\r\n    async def handle_object_not_found(self, failed_step, original_plan):\r\n        \"\"\"Handle the case where expected object is not found\"\"\"\r\n        self.get_logger().info('Handling object not found scenario')\r\n\r\n        # Request clarification from user\r\n        clarification_needed = {\r\n            'type': 'object_not_found',\r\n            'step_id': failed_step['step_id'],\r\n            'expected_object': failed_step['parameters']['target_object'],\r\n            'search_area': failed_step['parameters']['search_area']\r\n        }\r\n\r\n        self.publish_status('Object not found, requesting clarification or re-planning')\r\n\r\n        # Option 1: Ask for clarification\r\n        user_response = await self.request_user_clarification(clarification_needed)\r\n\r\n        if user_response['action'] == 'reposition_search':\r\n            # Modify the plan to search in a different location\r\n            new_plan = await self.modify_plan_for_new_location(\r\n                original_plan, failed_step, user_response['new_location'])\r\n            return {'status': 'success', 'new_plan': new_plan}\r\n\r\n        elif user_response['action'] == 'different_object':\r\n            # Modify the plan to look for a different object\r\n            new_plan = await self.modify_plan_for_different_object(\r\n                original_plan, failed_step, user_response['new_object'])\r\n            return {'status': 'success', 'new_plan': new_plan}\r\n\r\n        elif user_response['action'] == 'abort':\r\n            return {'status': 'failure', 'reason': 'user_aborted'}\r\n\r\n        # Option 2: Try re-planning if no user input\r\n        else:\r\n            return await self.request_replanning(original_plan, failed_step)\r\n\r\n    async def handle_grasp_failure(self, failed_step):\r\n        \"\"\"Handle grasp failure with recovery strategies\"\"\"\r\n        self.get_logger().info('Handling grasp failure')\r\n\r\n        # Try alternative grasp approach\r\n        alternative_grasps = [\r\n            'side_grasp',\r\n            'bottom_grasp',\r\n            'suction_grasp'\r\n        ]\r\n\r\n        for grasp_type in alternative_grasps:\r\n            self.get_logger().info(f'Trying alternative grasp: {grasp_type}')\r\n\r\n            try:\r\n                # Attempt alternative grasp\r\n                success = await self.attempt_alternative_grasp(\r\n                    failed_step, grasp_type)\r\n\r\n                if success:\r\n                    self.get_logger().info(f'Alternative grasp {grasp_type} successful')\r\n                    return {'status': 'recovered'}\r\n\r\n            except Exception as e:\r\n                self.get_logger().warn(f'Alternative grasp {grasp_type} failed: {str(e)}')\r\n                continue\r\n\r\n        return {'status': 'failed', 'reason': 'all_grasp_attempts_failed'}\r\n\r\n    async def request_user_clarification(self, issue_details):\r\n        \"\"\"Request clarification from user when encountering issues\"\"\"\r\n        # In a real system, this would interface with a user interaction system\r\n        # For this example, we'll simulate user response\r\n\r\n        self.get_logger().info(f'Requesting clarification: {issue_details}')\r\n\r\n        # Simulate user response - in real system this would wait for actual user input\r\n        # For demonstration, return a default response\r\n        return {\r\n            'action': 'reposition_search',\r\n            'new_location': {'x': 1.2, 'y': 0.6, 'z': 0.8}\r\n        }\r\n\r\n    async def request_replanning(self, original_plan, failed_step):\r\n        \"\"\"Request re-planning from the planning system\"\"\"\r\n        self.get_logger().info('Requesting re-planning due to execution failure')\r\n\r\n        if not self.replan_client.service_is_ready():\r\n            return {'status': 'failure', 'reason': 'replan_service_not_available'}\r\n\r\n        request = Trigger.Request()\r\n        future = self.replan_client.call_async(request)\r\n\r\n        try:\r\n            response = await future\r\n            if response.success:\r\n                # In a real system, the replan service would return a new plan\r\n                # For this example, we'll return a placeholder\r\n                return {\r\n                    'status': 'success',\r\n                    'new_plan': original_plan  # Placeholder - would be new plan in real system\r\n                }\r\n            else:\r\n                return {'status': 'failure', 'reason': 'replan_service_failed'}\r\n        except Exception as e:\r\n            return {'status': 'failure', 'reason': f'replan_request_failed: {str(e)}'}\r\n\r\n    def publish_status(self, status_msg):\r\n        \"\"\"Publish execution status\"\"\"\r\n        status = String()\r\n        status.data = status_msg\r\n        self.status_publisher.publish(status)\r\n\r\n    def publish_feedback(self, feedback_msg):\r\n        \"\"\"Publish execution feedback\"\"\"\r\n        feedback = String()\r\n        feedback.data = feedback_msg\r\n        self.feedback_publisher.publish(feedback)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    executor = rclpy.executors.MultiThreadedExecutor()\r\n\r\n    execution_manager = VLAExecutionManager()\r\n    executor.add_node(execution_manager)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        execution_manager.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"example-safety-boundary-implementation",children:"Example: Safety Boundary Implementation"}),"\n",(0,a.jsx)(n.p,{children:"Implementing comprehensive safety boundaries for VLA system execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Complete safety boundary implementation\r\nimport threading\r\nimport time\r\nfrom enum import Enum\r\nfrom dataclasses import dataclass\r\nfrom typing import Dict, List, Any, Optional\r\nimport math\r\n\r\nclass SafetyLevel(Enum):\r\n    CRITICAL = "critical"\r\n    WARNING = "warning"\r\n    INFO = "info"\r\n\r\n@dataclass\r\nclass SafetyConstraint:\r\n    name: str\r\n    constraint_type: str\r\n    parameters: Dict[str, Any]\r\n    enabled: bool = True\r\n\r\nclass SafetyBoundaryManager:\r\n    def __init__(self):\r\n        self.constraints = []\r\n        self.active_monitoring = True\r\n        self.safety_violations = []\r\n        self.emergency_stop_active = False\r\n        self.monitoring_thread = None\r\n\r\n        # Initialize default safety constraints\r\n        self._initialize_default_constraints()\r\n\r\n    def _initialize_default_constraints(self):\r\n        """Initialize default safety constraints for VLA systems"""\r\n        self.constraints = [\r\n            SafetyConstraint(\r\n                name="workspace_boundary",\r\n                constraint_type="position",\r\n                parameters={\r\n                    "min_position": {"x": -2.0, "y": -2.0, "z": 0.0},\r\n                    "max_position": {"x": 2.0, "y": 2.0, "z": 2.0}\r\n                }\r\n            ),\r\n            SafetyConstraint(\r\n                name="joint_limits",\r\n                constraint_type="joint",\r\n                parameters={\r\n                    "max_velocity": 1.0,  # rad/s\r\n                    "max_effort": 100.0,  # Nm\r\n                    "position_bounds": {\r\n                        "min": [-3.14, -1.57, -3.14],\r\n                        "max": [3.14, 1.57, 3.14]\r\n                    }\r\n                }\r\n            ),\r\n            SafetyConstraint(\r\n                name="human_safety_zone",\r\n                constraint_type="proximity",\r\n                parameters={\r\n                    "safe_distance": 1.0,  # meters\r\n                    "detection_threshold": 0.8  # confidence for human detection\r\n                }\r\n            ),\r\n            SafetyConstraint(\r\n                name="payload_limit",\r\n                constraint_type="force",\r\n                parameters={\r\n                    "max_payload": 5.0,  # kg\r\n                    "max_force": 100.0   # Newtons\r\n                }\r\n            ),\r\n            SafetyConstraint(\r\n                name="collision_avoidance",\r\n                constraint_type="collision",\r\n                parameters={\r\n                    "min_distance": 0.1,  # meters\r\n                    "buffer_zone": 0.05   # meters\r\n                }\r\n            )\r\n        ]\r\n\r\n    def start_monitoring(self):\r\n        """Start continuous safety monitoring"""\r\n        if self.monitoring_thread is None:\r\n            self.active_monitoring = True\r\n            self.monitoring_thread = threading.Thread(target=self._monitoring_loop)\r\n            self.monitoring_thread.daemon = True\r\n            self.monitoring_thread.start()\r\n            print("Safety monitoring started")\r\n\r\n    def stop_monitoring(self):\r\n        """Stop safety monitoring"""\r\n        self.active_monitoring = False\r\n        if self.monitoring_thread:\r\n            self.monitoring_thread.join()\r\n        print("Safety monitoring stopped")\r\n\r\n    def _monitoring_loop(self):\r\n        """Continuous monitoring loop"""\r\n        while self.active_monitoring:\r\n            if not self.emergency_stop_active:\r\n                self._check_all_constraints()\r\n            time.sleep(0.1)  # Check every 100ms\r\n\r\n    def _check_all_constraints(self):\r\n        """Check all active safety constraints"""\r\n        current_state = self._get_current_robot_state()\r\n\r\n        for constraint in self.constraints:\r\n            if constraint.enabled:\r\n                result = self._evaluate_constraint(constraint, current_state)\r\n                if result[\'violation\']:\r\n                    self._handle_violation(constraint, result)\r\n\r\n    def _evaluate_constraint(self, constraint: SafetyConstraint, state: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Evaluate a specific safety constraint"""\r\n        if constraint.constraint_type == "position":\r\n            return self._check_position_constraint(constraint, state)\r\n        elif constraint.constraint_type == "joint":\r\n            return self._check_joint_constraint(constraint, state)\r\n        elif constraint.constraint_type == "proximity":\r\n            return self._check_proximity_constraint(constraint, state)\r\n        elif constraint.constraint_type == "force":\r\n            return self._check_force_constraint(constraint, state)\r\n        elif constraint.constraint_type == "collision":\r\n            return self._check_collision_constraint(constraint, state)\r\n        else:\r\n            return {"violation": False, "message": "Unknown constraint type"}\r\n\r\n    def _check_position_constraint(self, constraint: SafetyConstraint, state: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Check position boundary constraints"""\r\n        current_pos = state.get(\'position\', {\'x\': 0, \'y\': 0, \'z\': 0})\r\n        min_pos = constraint.parameters[\'min_position\']\r\n        max_pos = constraint.parameters[\'max_position\']\r\n\r\n        violation = (\r\n            current_pos[\'x\'] < min_pos[\'x\'] or current_pos[\'x\'] > max_pos[\'x\'] or\r\n            current_pos[\'y\'] < min_pos[\'y\'] or current_pos[\'y\'] > max_pos[\'y\'] or\r\n            current_pos[\'z\'] < min_pos[\'z\'] or current_pos[\'z\'] > max_pos[\'z\']\r\n        )\r\n\r\n        if violation:\r\n            return {\r\n                "violation": True,\r\n                "level": SafetyLevel.CRITICAL,\r\n                "message": f"Position boundary violation: {current_pos} outside [{min_pos}, {max_pos}]",\r\n                "current_value": current_pos,\r\n                "bounds": [min_pos, max_pos]\r\n            }\r\n\r\n        return {"violation": False}\r\n\r\n    def _check_joint_constraint(self, constraint: SafetyConstraint, state: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Check joint limit constraints"""\r\n        current_joints = state.get(\'joints\', [])\r\n        position_bounds = constraint.parameters[\'position_bounds\']\r\n\r\n        # Check position limits\r\n        for i, pos in enumerate(current_joints.get(\'positions\', [])):\r\n            if i < len(position_bounds[\'min\']) and i < len(position_bounds[\'max\']):\r\n                if pos < position_bounds[\'min\'][i] or pos > position_bounds[\'max\'][i]:\r\n                    return {\r\n                        "violation": True,\r\n                        "level": SafetyLevel.CRITICAL,\r\n                        "message": f"Joint position limit violation: joint {i} at {pos}",\r\n                        "current_value": pos,\r\n                        "bounds": [position_bounds[\'min\'][i], position_bounds[\'max\'][i]]\r\n                    }\r\n\r\n        # Check velocity limits\r\n        max_velocity = constraint.parameters[\'max_velocity\']\r\n        current_velocities = current_joints.get(\'velocities\', [])\r\n        for vel in current_velocities:\r\n            if abs(vel) > max_velocity:\r\n                return {\r\n                    "violation": True,\r\n                    "level": SafetyLevel.WARNING,\r\n                    "message": f"Joint velocity limit violation: {vel} > {max_velocity}",\r\n                    "current_value": vel,\r\n                    "limit": max_velocity\r\n                }\r\n\r\n        return {"violation": False}\r\n\r\n    def _check_proximity_constraint(self, constraint: SafetyConstraint, state: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Check proximity to humans or obstacles"""\r\n        safe_distance = constraint.parameters[\'safe_distance\']\r\n        human_detections = state.get(\'human_detections\', [])\r\n\r\n        for detection in human_detections:\r\n            distance = detection.get(\'distance\', float(\'inf\'))\r\n            if distance < safe_distance:\r\n                return {\r\n                    "violation": True,\r\n                    "level": SafetyLevel.WARNING,\r\n                    "message": f"Human proximity violation: {distance:.2f}m < {safe_distance}m",\r\n                    "current_value": distance,\r\n                    "limit": safe_distance,\r\n                    "human_position": detection.get(\'position\')\r\n                }\r\n\r\n        return {"violation": False}\r\n\r\n    def _check_force_constraint(self, constraint: SafetyConstraint, state: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Check force and payload constraints"""\r\n        current_payload = state.get(\'current_payload\', 0.0)\r\n        max_payload = constraint.parameters[\'max_payload\']\r\n\r\n        if current_payload > max_payload:\r\n            return {\r\n                "violation": True,\r\n                "level": SafetyLevel.CRITICAL,\r\n                "message": f"Payload limit violation: {current_payload}kg > {max_payload}kg",\r\n                "current_value": current_payload,\r\n                "limit": max_payload\r\n            }\r\n\r\n        return {"violation": False}\r\n\r\n    def _check_collision_constraint(self, constraint: SafetyConstraint, state: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Check for potential collisions"""\r\n        min_distance = constraint.parameters[\'min_distance\']\r\n        obstacles = state.get(\'obstacles\', [])\r\n\r\n        for obstacle in obstacles:\r\n            distance = obstacle.get(\'distance\', float(\'inf\'))\r\n            if distance < min_distance:\r\n                return {\r\n                    "violation": True,\r\n                    "level": SafetyLevel.CRITICAL,\r\n                    "message": f"Collision risk: obstacle at {distance:.2f}m < {min_distance}m",\r\n                    "current_value": distance,\r\n                    "limit": min_distance,\r\n                    "obstacle_position": obstacle.get(\'position\')\r\n                }\r\n\r\n        return {"violation": False}\r\n\r\n    def _handle_violation(self, constraint: SafetyConstraint, violation_result: Dict[str, Any]):\r\n        """Handle a safety constraint violation"""\r\n        self.safety_violations.append({\r\n            \'timestamp\': time.time(),\r\n            \'constraint\': constraint.name,\r\n            \'result\': violation_result\r\n        })\r\n\r\n        if violation_result[\'level\'] == SafetyLevel.CRITICAL:\r\n            self.trigger_emergency_stop()\r\n\r\n        print(f"Safety violation: {violation_result[\'message\']}")\r\n\r\n        # Log the violation for analysis\r\n        self._log_violation(constraint, violation_result)\r\n\r\n    def trigger_emergency_stop(self):\r\n        """Trigger emergency stop for critical violations"""\r\n        if not self.emergency_stop_active:\r\n            print("EMERGENCY STOP TRIGGERED - Critical safety violation detected")\r\n            self.emergency_stop_active = True\r\n            # In a real system, this would send emergency stop commands to all controllers\r\n\r\n    def clear_emergency_stop(self):\r\n        """Clear emergency stop condition"""\r\n        self.emergency_stop_active = False\r\n        print("Emergency stop cleared")\r\n\r\n    def _get_current_robot_state(self) -> Dict[str, Any]:\r\n        """Get current robot state for monitoring (simulated)"""\r\n        # In a real system, this would interface with the robot\'s state estimation\r\n        return {\r\n            \'position\': {\'x\': 0.5, \'y\': 0.3, \'z\': 0.8},\r\n            \'joints\': {\r\n                \'positions\': [0.1, 0.2, 0.3],\r\n                \'velocities\': [0.05, 0.03, 0.02]\r\n            },\r\n            \'current_payload\': 2.5,\r\n            \'human_detections\': [],\r\n            \'obstacles\': []\r\n        }\r\n\r\n    def _log_violation(self, constraint: SafetyConstraint, violation_result: Dict[str, Any]):\r\n        """Log safety violation for analysis"""\r\n        # In a real system, this would write to a safety log file\r\n        pass\r\n\r\n    def validate_action_safety(self, action: Dict[str, Any]) -> Dict[str, Any]:\r\n        """Validate a specific action against safety constraints before execution"""\r\n        validation_result = {\r\n            \'safe\': True,\r\n            \'violations\': [],\r\n            \'warnings\': []\r\n        }\r\n\r\n        # Check if emergency stop is active\r\n        if self.emergency_stop_active:\r\n            validation_result[\'safe\'] = False\r\n            validation_result[\'violations\'].append("Emergency stop is active")\r\n            return validation_result\r\n\r\n        # Validate action parameters against constraints\r\n        for constraint in self.constraints:\r\n            if constraint.enabled and constraint.name != "collision_avoidance":\r\n                # For this example, we\'ll do basic validation\r\n                # In a real system, this would be more detailed\r\n                pass\r\n\r\n        return validation_result\r\n\r\n# Example usage in VLA execution system\r\nclass SafeVLAExecutionSystem:\r\n    def __init__(self):\r\n        self.safety_manager = SafetyBoundaryManager()\r\n        self.safety_manager.start_monitoring()\r\n\r\n    async def execute_action_safely(self, action: Dict[str, Any]):\r\n        """Execute an action with safety validation"""\r\n        # Validate action before execution\r\n        validation = self.safety_manager.validate_action_safety(action)\r\n\r\n        if not validation[\'safe\']:\r\n            return {\r\n                \'status\': \'blocked\',\r\n                \'reason\': \'Safety validation failed\',\r\n                \'violations\': validation[\'violations\']\r\n            }\r\n\r\n        # Execute the action (in a real system, this would interface with ROS 2)\r\n        try:\r\n            # Simulate action execution\r\n            execution_result = await self._execute_ros2_action(action)\r\n\r\n            return {\r\n                \'status\': \'completed\',\r\n                \'result\': execution_result\r\n            }\r\n        except Exception as e:\r\n            return {\r\n                \'status\': \'failed\',\r\n                \'error\': str(e)\r\n            }\r\n\r\n    async def _execute_ros2_action(self, action: Dict[str, Any]):\r\n        """Execute ROS 2 action (simulated)"""\r\n        # Simulate action execution\r\n        await asyncio.sleep(0.1)  # Simulate execution time\r\n        return {\'success\': True, \'details\': \'Action completed successfully\'}\r\n\r\n    def shutdown(self):\r\n        """Shutdown the safety system"""\r\n        self.safety_manager.stop_monitoring()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"summary--key-takeaways",children:"Summary & Key Takeaways"}),"\n",(0,a.jsx)(n.p,{children:"In this chapter, you've learned about action execution and safety in VLA systems:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Mapping plans to ROS 2 actions"})," involves converting high-level plan steps into concrete action executions with proper parameters and dependencies"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Action monitoring and feedback"})," ensures that plan execution proceeds as expected and detects deviations or failures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Failure recovery strategies"})," handle situations where actions fail, including re-planning and clarification requests"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safety boundaries"})," provide multiple layers of protection to ensure safe operation in the physical world"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You've seen practical examples of converting plans to ROS 2 action graphs, implementing failure detection and re-planning when objects aren't found, and creating comprehensive safety boundary systems. The emphasis throughout is on maintaining safety while enabling effective robot operation in response to natural language commands."}),"\n",(0,a.jsx)(n.p,{children:"These execution and safety systems complete the VLA architecture, providing the critical safety layer that enables LLM-generated plans to be safely executed in the physical world. The separation of planning from execution, combined with comprehensive safety monitoring and failure recovery, enables the development of robust and safe VLA systems that can bridge human intent with physical robot actions."}),"\n",(0,a.jsx)(n.p,{children:"This concludes Module 6: Vision\u2013Language\u2013Action (VLA) Systems. You now have a comprehensive understanding of how to design, plan, and safely execute VLA systems that can interpret natural language commands and execute them through physical robot actions while maintaining the safety and determinism required for real-world deployment. These foundations prepare you for the capstone autonomous humanoid system."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453(e,n,r){r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);