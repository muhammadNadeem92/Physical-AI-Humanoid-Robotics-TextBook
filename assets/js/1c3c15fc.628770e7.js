"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[158],{1181(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-06-vla-systems/llm-planning","title":"Chapter 3: Cognitive Planning with LLMs","description":"Introduction","source":"@site/docs/module-06-vla-systems/llm-planning.md","sourceDirName":"module-06-vla-systems","slug":"/module-06-vla-systems/llm-planning","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-06-vla-systems/llm-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadNadeem92/Physical-AI-Humanoid-Robotics-TextBook/tree/main/docs/module-06-vla-systems/llm-planning.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Voice & Language Understanding","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-06-vla-systems/voice-language"},"next":{"title":"Chapter 4: Action Execution & Safety","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-06-vla-systems/action-safety"}}');var a=t(4848),s=t(8453);const i={},o="Chapter 3: Cognitive Planning with LLMs",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"LLMs as Planners vs Executors",id:"llms-as-planners-vs-executors",level:3},{value:"Task Decomposition",id:"task-decomposition",level:3},{value:"State Awareness",id:"state-awareness",level:3},{value:"Tool Calling &amp; Function Schemas",id:"tool-calling--function-schemas",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: Converting Command to Step-by-Step Plan",id:"example-converting-command-to-step-by-step-plan",level:3},{value:"Example: Enforcing Constraints (Reachability, Safety)",id:"example-enforcing-constraints-reachability-safety",level:3},{value:"Example: Plan Validation Before Execution",id:"example-plan-validation-before-execution",level:3},{value:"Summary &amp; Key Takeaways",id:"summary--key-takeaways",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-3-cognitive-planning-with-llms",children:"Chapter 3: Cognitive Planning with LLMs"})}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"In the previous chapter, you learned how to convert voice and text commands into structured JSON task schemas. Now we'll explore cognitive planning with Large Language Models (LLMs), focusing on using LLMs as task planners rather than direct motor controllers."}),"\n",(0,a.jsx)(e.p,{children:"The key insight in VLA systems is that LLMs serve as high-level planners that decompose complex commands into detailed execution sequences, while leaving low-level motor control to specialized robotic systems. This separation ensures safety, determinism, and proper constraint enforcement while leveraging the powerful reasoning capabilities of LLMs for task planning."}),"\n",(0,a.jsx)(e.p,{children:"This chapter covers LLMs as planners versus executors, task decomposition techniques, state awareness in planning systems, and tool calling with function schemas. You'll learn how to convert high-level commands to step-by-step plans, enforce constraints like reachability and safety, and validate plans before execution."}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, you'll understand how to leverage LLMs for intelligent task planning while maintaining the critical safety boundaries that separate planning from execution in VLA systems."}),"\n",(0,a.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(e.h3,{id:"llms-as-planners-vs-executors",children:"LLMs as Planners vs Executors"}),"\n",(0,a.jsx)(e.p,{children:"Large Language Models serve as planners in VLA systems, not as direct executors of low-level motor commands:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Planning Responsibilities"}),": LLMs handle high-level task decomposition, reasoning about object relationships, spatial reasoning, and generating structured action sequences that can be executed by robotic systems."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Execution Boundaries"}),": LLMs do not directly control motors, joints, or low-level robotic functions. Instead, they generate plans that are executed by specialized robotic control systems."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Abstraction Layer"}),': LLMs operate at a higher level of abstraction, focusing on "what" needs to be done rather than "how" to move individual joints or control low-level systems.']}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Safety Mediation"}),": The planning layer acts as a safety buffer, validating high-level goals and constraints before they reach execution systems."]}),"\n",(0,a.jsx)(e.h3,{id:"task-decomposition",children:"Task Decomposition"}),"\n",(0,a.jsx)(e.p,{children:"Task decomposition breaks complex commands into sequences of simpler, executable actions:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Hierarchical Decomposition"}),": Breaking complex tasks into subtasks that can be further decomposed until reaching primitive actions that can be executed by the robotic system."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Dependency Analysis"}),": Identifying dependencies between subtasks to determine the correct execution order and parallelization opportunities."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Prerequisite Identification"}),": Determining what conditions must be met before each subtask can be executed successfully."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Fallback Planning"}),": Creating alternative sequences for handling common failure modes during execution."]}),"\n",(0,a.jsx)(e.h3,{id:"state-awareness",children:"State Awareness"}),"\n",(0,a.jsx)(e.p,{children:"State awareness enables planning systems to account for the current situation and environment:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"World State Representation"}),": Maintaining an up-to-date representation of the environment, objects, and their relationships to inform planning decisions."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Robot State Integration"}),": Incorporating information about the robot's current configuration, capabilities, and limitations into planning decisions."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Temporal State Tracking"}),": Understanding how the world state changes as tasks are executed and planning accordingly."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Uncertainty Handling"}),": Managing uncertainty in state information and planning robustly despite incomplete or potentially incorrect state knowledge."]}),"\n",(0,a.jsx)(e.h3,{id:"tool-calling--function-schemas",children:"Tool Calling & Function Schemas"}),"\n",(0,a.jsx)(e.p,{children:"Tool calling enables LLMs to interact with external systems and services during planning:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Function Schema Definition"}),": Creating structured schemas that define the inputs, outputs, and constraints for external tools and services that the LLM can call."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"API Integration"}),": Enabling LLMs to call external APIs for perception, navigation, manipulation, and other robotic functions."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Constraint Checking"}),": Using tool calls to validate constraints like reachability, collision detection, and safety requirements."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Feedback Integration"}),": Incorporating results from tool calls back into the planning process to refine or adjust the plan."]}),"\n",(0,a.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(e.h3,{id:"example-converting-command-to-step-by-step-plan",children:"Example: Converting Command to Step-by-Step Plan"}),"\n",(0,a.jsx)(e.p,{children:"Converting a high-level command into a detailed step-by-step execution plan:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",children:'{\r\n  "plan_id": "plan_001",\r\n  "original_command": "Pick up the red bottle from the table",\r\n  "plan": [\r\n    {\r\n      "step_id": "step_001",\r\n      "action": "approach_location",\r\n      "parameters": {\r\n        "location": "near_table",\r\n        "safety_margin": 0.5\r\n      },\r\n      "preconditions": [\r\n        "robot_is_idle",\r\n        "location_is_reachable"\r\n      ],\r\n      "postconditions": [\r\n        "robot_is_near_table"\r\n      ],\r\n      "timeout": 30\r\n    },\r\n    {\r\n      "step_id": "step_002",\r\n      "action": "perceive_environment",\r\n      "parameters": {\r\n        "target_object": "red bottle",\r\n        "search_area": "table_surface"\r\n      },\r\n      "preconditions": [\r\n        "robot_is_near_table"\r\n      ],\r\n      "postconditions": [\r\n        "object_location_confirmed",\r\n        "grasp_feasibility_verified"\r\n      ],\r\n      "timeout": 10\r\n    },\r\n    {\r\n      "step_id": "step_003",\r\n      "action": "plan_grasp",\r\n      "parameters": {\r\n        "object": "red bottle",\r\n        "grasp_type": "top_grasp",\r\n        "gripper": "left"\r\n      },\r\n      "preconditions": [\r\n        "object_location_confirmed",\r\n        "grasp_feasibility_verified"\r\n      ],\r\n      "postconditions": [\r\n        "grasp_plan_generated",\r\n        "collision_free_path_confirmed"\r\n      ],\r\n      "timeout": 15\r\n    },\r\n    {\r\n      "step_id": "step_004",\r\n      "action": "execute_grasp",\r\n      "parameters": {\r\n        "grasp_plan": "grasp_plan_generated"\r\n      },\r\n      "preconditions": [\r\n        "grasp_plan_generated",\r\n        "collision_free_path_confirmed"\r\n      ],\r\n      "postconditions": [\r\n        "object_grasped",\r\n        "gripper_state_confirmed"\r\n      ],\r\n      "timeout": 20\r\n    },\r\n    {\r\n      "step_id": "step_005",\r\n      "action": "lift_object",\r\n      "parameters": {\r\n        "height": 0.1,\r\n        "speed": "normal"\r\n      },\r\n      "preconditions": [\r\n        "object_grasped"\r\n      ],\r\n      "postconditions": [\r\n        "object_lifted",\r\n        "stable_grasp_confirmed"\r\n      ],\r\n      "timeout": 10\r\n    }\r\n  ],\r\n  "constraints": {\r\n    "safety_constraints": [\r\n      "avoid_collisions",\r\n      "respect_workspace_limits",\r\n      "maintain_stability"\r\n    ],\r\n    "execution_constraints": [\r\n      "max_execution_time: 120",\r\n      "precision_requirements: standard"\r\n    ]\r\n  },\r\n  "fallback_procedures": [\r\n    {\r\n      "trigger": "object_not_found",\r\n      "procedure": "request_user_clarification"\r\n    },\r\n    {\r\n      "trigger": "grasp_failure",\r\n      "procedure": "attempt_alternative_grasp"\r\n    },\r\n    {\r\n      "trigger": "collision_detected",\r\n      "procedure": "abort_and_replan"\r\n    }\r\n  ]\r\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"This detailed plan breaks down the high-level command into executable steps with preconditions, postconditions, and safety constraints."}),"\n",(0,a.jsx)(e.h3,{id:"example-enforcing-constraints-reachability-safety",children:"Example: Enforcing Constraints (Reachability, Safety)"}),"\n",(0,a.jsx)(e.p,{children:"Implementing constraint enforcement in planning systems:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Example Python code for constraint enforcement\r\nclass ConstraintEnforcer:\r\n    def __init__(self):\r\n        self.kinematics_solver = KinematicsSolver()\r\n        self.collision_detector = CollisionDetector()\r\n        self.safety_checker = SafetyChecker()\r\n\r\n    def enforce_reachability_constraint(self, plan_step):\r\n        \"\"\"Enforce reachability constraints for manipulation tasks\"\"\"\r\n        if plan_step['action'] == 'execute_grasp':\r\n            object_pose = plan_step['parameters']['object_pose']\r\n            robot_base_pose = plan_step['parameters']['robot_pose']\r\n\r\n            # Check if the object is within the robot's reachable workspace\r\n            is_reachable = self.kinematics_solver.check_reachability(\r\n                object_pose,\r\n                robot_base_pose\r\n            )\r\n\r\n            if not is_reachable:\r\n                return {\r\n                    'valid': False,\r\n                    'error': 'Target object is not reachable from current position',\r\n                    'suggestion': 'Approach the object first or reposition the robot'\r\n                }\r\n\r\n            # Check if the grasp approach direction is feasible\r\n            grasp_approach = plan_step['parameters']['grasp_approach']\r\n            is_approachable = self.kinematics_solver.check_approach_feasibility(\r\n                object_pose,\r\n                grasp_approach\r\n            )\r\n\r\n            if not is_approachable:\r\n                return {\r\n                    'valid': False,\r\n                    'error': 'Grasp approach direction is not kinematically feasible',\r\n                    'suggestion': 'Try a different grasp approach or reposition'\r\n                }\r\n\r\n        return {'valid': True}\r\n\r\n    def enforce_safety_constraints(self, plan_step):\r\n        \"\"\"Enforce safety constraints for all plan steps\"\"\"\r\n        # Check for potential collisions during the action\r\n        if 'path' in plan_step['parameters']:\r\n            path = plan_step['parameters']['path']\r\n            has_collision = self.collision_detector.check_path_collision(path)\r\n\r\n            if has_collision:\r\n                return {\r\n                    'valid': False,\r\n                    'error': 'Path contains potential collision risks',\r\n                    'suggestion': 'Replan path to avoid obstacles'\r\n                }\r\n\r\n        # Check safety zones and restricted areas\r\n        if 'location' in plan_step['parameters']:\r\n            location = plan_step['parameters']['location']\r\n            is_safe = self.safety_checker.check_location_safety(location)\r\n\r\n            if not is_safe:\r\n                return {\r\n                    'valid': False,\r\n                    'error': 'Target location is in a restricted or unsafe area',\r\n                    'suggestion': 'Choose a different location or verify safety permissions'\r\n                }\r\n\r\n        # Check for dynamic safety constraints (e.g., humans in area)\r\n        dynamic_safety = self.safety_checker.check_dynamic_safety()\r\n        if not dynamic_safety['safe']:\r\n            return {\r\n                'valid': False,\r\n                'error': f'Dynamic safety issue: {dynamic_safety[\"issue\"]}',\r\n                'suggestion': dynamic_safety['suggestion']\r\n            }\r\n\r\n        return {'valid': True}\r\n\r\n    def validate_plan_step(self, plan_step, current_state):\r\n        \"\"\"Validate a plan step against all relevant constraints\"\"\"\r\n        # Check reachability constraints\r\n        reachability_result = self.enforce_reachability_constraint(plan_step)\r\n        if not reachability_result['valid']:\r\n            return reachability_result\r\n\r\n        # Check safety constraints\r\n        safety_result = self.enforce_safety_constraints(plan_step)\r\n        if not safety_result['valid']:\r\n            return safety_result\r\n\r\n        # Check other domain-specific constraints\r\n        domain_result = self.check_domain_constraints(plan_step, current_state)\r\n        if not domain_result['valid']:\r\n            return domain_result\r\n\r\n        return {\r\n            'valid': True,\r\n            'validated_step': plan_step\r\n        }\r\n\r\n    def check_domain_constraints(self, plan_step, current_state):\r\n        \"\"\"Check domain-specific constraints\"\"\"\r\n        # Example: Check if the robot has the required tools/attachments\r\n        if plan_step['action'] == 'use_tool':\r\n            required_tool = plan_step['parameters']['required_tool']\r\n            if not current_state['available_tools'].get(required_tool):\r\n                return {\r\n                    'valid': False,\r\n                    'error': f'Required tool {required_tool} is not available',\r\n                    'suggestion': 'Verify tool attachment or select different approach'\r\n                }\r\n\r\n        # Example: Check payload constraints\r\n        if plan_step['action'] == 'lift_object':\r\n            object_weight = plan_step['parameters']['object_weight']\r\n            max_payload = current_state['robot_specs']['max_payload']\r\n\r\n            if object_weight > max_payload:\r\n                return {\r\n                    'valid': False,\r\n                    'error': f'Object weight ({object_weight}kg) exceeds maximum payload ({max_payload}kg)',\r\n                    'suggestion': 'Select a lighter object or use specialized equipment'\r\n                }\r\n\r\n        return {'valid': True}\r\n\r\n# Example usage of constraint enforcement\r\nclass PlanningSystem:\r\n    def __init__(self):\r\n        self.constraint_enforcer = ConstraintEnforcer()\r\n        self.llm_planner = LLMPlanner()\r\n\r\n    def generate_and_validate_plan(self, command, current_state):\r\n        \"\"\"Generate plan and validate all constraints\"\"\"\r\n        # Generate initial plan using LLM\r\n        raw_plan = self.llm_planner.generate_plan(command)\r\n\r\n        # Validate each step in the plan\r\n        validated_plan = []\r\n        for step in raw_plan['plan']:\r\n            validation_result = self.constraint_enforcer.validate_plan_step(step, current_state)\r\n\r\n            if not validation_result['valid']:\r\n                return {\r\n                    'status': 'validation_failed',\r\n                    'error_step': step['step_id'],\r\n                    'error': validation_result['error'],\r\n                    'suggestion': validation_result['suggestion']\r\n                }\r\n\r\n            validated_plan.append(validation_result['validated_step'])\r\n\r\n        # Update the plan with validated steps\r\n        raw_plan['plan'] = validated_plan\r\n        raw_plan['status'] = 'validated'\r\n\r\n        return raw_plan\n"})}),"\n",(0,a.jsx)(e.h3,{id:"example-plan-validation-before-execution",children:"Example: Plan Validation Before Execution"}),"\n",(0,a.jsx)(e.p,{children:"Implementing comprehensive plan validation before execution:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Complete plan validation system\r\nimport asyncio\r\nfrom typing import Dict, List, Any\r\nfrom enum import Enum\r\n\r\nclass ValidationStatus(Enum):\r\n    PASSED = \"passed\"\r\n    FAILED = \"failed\"\r\n    PARTIAL = \"partial\"\r\n\r\nclass PlanValidator:\r\n    def __init__(self):\r\n        self.reachability_checker = ReachabilityChecker()\r\n        self.safety_analyzer = SafetyAnalyzer()\r\n        self.resource_validator = ResourceValidator()\r\n        self.temporal_validator = TemporalValidator()\r\n\r\n    async def validate_plan(self, plan: Dict[str, Any], current_state: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Comprehensive plan validation before execution\"\"\"\r\n        validation_results = {\r\n            'overall_status': ValidationStatus.PASSED,\r\n            'validation_steps': [],\r\n            'warnings': [],\r\n            'errors': [],\r\n            'validated_plan': plan.copy()\r\n        }\r\n\r\n        # Validate each step in the plan\r\n        for step in plan['plan']:\r\n            step_result = await self._validate_single_step(step, current_state)\r\n\r\n            if step_result['status'] == ValidationStatus.FAILED:\r\n                validation_results['overall_status'] = ValidationStatus.FAILED\r\n                validation_results['errors'].extend(step_result['errors'])\r\n            elif step_result['status'] == ValidationStatus.PARTIAL:\r\n                validation_results['warnings'].extend(step_result['warnings'])\r\n\r\n            validation_results['validation_steps'].append(step_result)\r\n\r\n        # Perform cross-step validation\r\n        cross_validation = await self._validate_cross_step_dependencies(plan['plan'])\r\n        if cross_validation['errors']:\r\n            validation_results['overall_status'] = ValidationStatus.FAILED\r\n            validation_results['errors'].extend(cross_validation['errors'])\r\n\r\n        if cross_validation['warnings']:\r\n            validation_results['warnings'].extend(cross_validation['warnings'])\r\n\r\n        # Final temporal and resource validation\r\n        temporal_result = await self.temporal_validator.validate_temporal_constraints(plan)\r\n        if not temporal_result['valid']:\r\n            validation_results['overall_status'] = ValidationStatus.FAILED\r\n            validation_results['errors'].append(temporal_result['error'])\r\n\r\n        return validation_results\r\n\r\n    async def _validate_single_step(self, step: Dict[str, Any], current_state: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Validate a single plan step\"\"\"\r\n        step_validation = {\r\n            'step_id': step['step_id'],\r\n            'status': ValidationStatus.PASSED,\r\n            'errors': [],\r\n            'warnings': [],\r\n            'validated_parameters': step['parameters'].copy()\r\n        }\r\n\r\n        # Validate preconditions\r\n        preconditions_result = await self._validate_preconditions(step, current_state)\r\n        if not preconditions_result['satisfied']:\r\n            step_validation['status'] = ValidationStatus.FAILED\r\n            step_validation['errors'].extend(preconditions_result['errors'])\r\n\r\n        # Validate action-specific constraints\r\n        action_result = await self._validate_action_constraints(step)\r\n        if not action_result['valid']:\r\n            step_validation['status'] = ValidationStatus.FAILED\r\n            step_validation['errors'].append(action_result['error'])\r\n\r\n        # Validate safety constraints\r\n        safety_result = await self.safety_analyzer.check_step_safety(step, current_state)\r\n        if not safety_result['safe']:\r\n            if safety_result['severity'] == 'critical':\r\n                step_validation['status'] = ValidationStatus.FAILED\r\n                step_validation['errors'].append(safety_result['message'])\r\n            else:\r\n                step_validation['warnings'].append(safety_result['message'])\r\n\r\n        return step_validation\r\n\r\n    async def _validate_preconditions(self, step: Dict[str, Any], current_state: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Validate preconditions for a step\"\"\"\r\n        required_conditions = step.get('preconditions', [])\r\n        errors = []\r\n\r\n        for condition in required_conditions:\r\n            if condition == 'robot_is_idle':\r\n                if not current_state['robot_status'] == 'idle':\r\n                    errors.append('Robot must be idle before executing this step')\r\n\r\n            elif condition == 'location_is_reachable':\r\n                target_location = step['parameters'].get('location')\r\n                if target_location:\r\n                    is_reachable = await self.reachability_checker.check_location(target_location)\r\n                    if not is_reachable:\r\n                        errors.append(f'Location {target_location} is not reachable')\r\n\r\n        return {\r\n            'satisfied': len(errors) == 0,\r\n            'errors': errors\r\n        }\r\n\r\n    async def _validate_action_constraints(self, step: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Validate action-specific constraints\"\"\"\r\n        action = step['action']\r\n\r\n        if action == 'execute_grasp':\r\n            # Validate grasp-specific constraints\r\n            grasp_type = step['parameters'].get('grasp_type')\r\n            object_properties = step['parameters'].get('object_properties', {})\r\n\r\n            if grasp_type == 'top_grasp' and object_properties.get('width', 0) > 0.1:\r\n                return {\r\n                    'valid': False,\r\n                    'error': 'Top grasp not suitable for objects wider than 10cm'\r\n                }\r\n\r\n        elif action == 'approach_location':\r\n            # Validate approach-specific constraints\r\n            safety_margin = step['parameters'].get('safety_margin', 0.0)\r\n            if safety_margin < 0.1:\r\n                return {\r\n                    'valid': False,\r\n                    'error': 'Safety margin must be at least 0.1m for approach actions'\r\n                }\r\n\r\n        return {'valid': True}\r\n\r\n    async def _validate_cross_step_dependencies(self, plan_steps: List[Dict[str, Any]]) -> Dict[str, Any]:\r\n        \"\"\"Validate dependencies between plan steps\"\"\"\r\n        errors = []\r\n        warnings = []\r\n\r\n        for i, step in enumerate(plan_steps):\r\n            # Check if postconditions of previous steps satisfy preconditions of current step\r\n            if i > 0:\r\n                prev_step = plan_steps[i-1]\r\n                current_preconditions = step.get('preconditions', [])\r\n                prev_postconditions = prev_step.get('postconditions', [])\r\n\r\n                for precondition in current_preconditions:\r\n                    if precondition not in prev_postconditions:\r\n                        warnings.append(\r\n                            f'Step {step[\"step_id\"]} precondition \"{precondition}\" may not be satisfied by previous steps'\r\n                        )\r\n\r\n        return {\r\n            'errors': errors,\r\n            'warnings': warnings\r\n        }\r\n\r\n# Example of using the plan validator\r\nclass VLAPlanningSystem:\r\n    def __init__(self):\r\n        self.validator = PlanValidator()\r\n        self.llm_planner = AdvancedLLMPlanner()\r\n\r\n    async def plan_and_validate(self, natural_command: str, current_state: Dict[str, Any]) -> Dict[str, Any]:\r\n        \"\"\"Complete planning and validation workflow\"\"\"\r\n        # Generate plan using LLM\r\n        raw_plan = await self.llm_planner.generate_from_command(natural_command)\r\n\r\n        # Validate the complete plan\r\n        validation_result = await self.validator.validate_plan(raw_plan, current_state)\r\n\r\n        if validation_result['overall_status'] == ValidationStatus.FAILED:\r\n            return {\r\n                'status': 'planning_failed',\r\n                'reason': 'Plan validation failed',\r\n                'validation_result': validation_result\r\n            }\r\n\r\n        # Plan is valid, ready for execution\r\n        return {\r\n            'status': 'planning_successful',\r\n            'plan': validation_result['validated_plan'],\r\n            'validation_result': validation_result,\r\n            'warnings': validation_result['warnings']\r\n        }\n"})}),"\n",(0,a.jsx)(e.h2,{id:"summary--key-takeaways",children:"Summary & Key Takeaways"}),"\n",(0,a.jsx)(e.p,{children:"In this chapter, you've learned about cognitive planning with LLMs in VLA systems:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"LLMs serve as planners, not executors"}),", operating at a high level of abstraction while leaving low-level control to specialized systems"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Task decomposition"})," breaks complex commands into sequences of simpler, executable actions with proper dependencies"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"State awareness"})," enables planning systems to account for current conditions and environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Tool calling and function schemas"})," allow LLMs to interact with external systems for constraint checking and validation"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"You've seen practical examples of converting high-level commands to detailed step-by-step plans, implementing constraint enforcement for reachability and safety, and creating comprehensive validation systems before plan execution. The emphasis throughout is on maintaining the critical separation between planning and execution, ensuring that LLMs plan safely while specialized systems handle the actual physical execution."}),"\n",(0,a.jsx)(e.p,{children:"These planning capabilities form the intelligence layer of VLA systems, bridging the gap between natural language commands and executable robot actions while maintaining the safety and determinism required for physical robot operation. In the next chapter, you'll explore how these plans are safely executed through ROS 2 actions with proper monitoring and failure recovery."})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8453(n,e,t){t.d(e,{R:()=>i,x:()=>o});var r=t(6540);const a={},s=r.createContext(a);function i(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);