"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[920],{2585(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"module-02-ros2/nodes-topics-messages","title":"Chapter 2: Nodes, Topics, and Messages","description":"Introduction","source":"@site/docs/module-02-ros2/nodes-topics-messages.md","sourceDirName":"module-02-ros2","slug":"/module-02-ros2/nodes-topics-messages","permalink":"/docs/module-02-ros2/nodes-topics-messages","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadNadeem92/physical-ai-humanoid-robotics-textbook/tree/main/docs/module-02-ros2/nodes-topics-messages.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: ROS 2 Architecture & Setup","permalink":"/docs/module-02-ros2/architecture-setup"},"next":{"title":"Chapter 3: Services, Actions, and Launch Files","permalink":"/docs/module-02-ros2/services-actions-launch"}}');var i=n(4848),t=n(8453);const o={},a="Chapter 2: Nodes, Topics, and Messages",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Nodes as Processes",id:"nodes-as-processes",level:3},{value:"Topics as Data Streams",id:"topics-as-data-streams",level:3},{value:"Publishers and Subscribers",id:"publishers-and-subscribers",level:3},{value:"Message Types and Structure",id:"message-types-and-structure",level:3},{value:"Examples",id:"examples",level:2},{value:"Python rclpy Publisher Example",id:"python-rclpy-publisher-example",level:3},{value:"Python rclpy Subscriber Example",id:"python-rclpy-subscriber-example",level:3},{value:"Running Publisher and Subscriber",id:"running-publisher-and-subscriber",level:3},{value:"Custom Message Type Example",id:"custom-message-type-example",level:3},{value:"Topic Introspection Using CLI",id:"topic-introspection-using-cli",level:3},{value:"ROS Graph Visualization",id:"ros-graph-visualization",level:3},{value:"Summary &amp; Key Takeaways",id:"summary--key-takeaways",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"chapter-2-nodes-topics-and-messages",children:"Chapter 2: Nodes, Topics, and Messages"})}),"\n",(0,i.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(s.p,{children:"In Chapter 1, you learned about ROS 2 as the nervous system for Physical AI systems and set up your development environment. Now we'll dive deeper into the fundamental communication patterns that make distributed robotics possible: nodes, topics, and messages."}),"\n",(0,i.jsx)(s.p,{children:"Recall from Module 1 that Physical AI systems require tight integration between perception (sensors), reasoning (AI), and action (actuators). In the context of ROS 2, think of nodes as specialized brain regions, each responsible for a specific function. For example, one node might process camera data to detect objects (perception), another might plan navigation paths (reasoning), and a third might control the robot's motors (actuation). These nodes need to communicate with each other seamlessly, sharing sensor data, commands, and status updates. This is where topics and messages come in - they provide the communication channels and the format for the information being shared, enabling the tight integration between perception, reasoning, and actuation that defines Physical AI systems."}),"\n",(0,i.jsx)(s.p,{children:"By the end of this chapter, you'll understand how to create nodes that publish and subscribe to topics, how to define custom message types, and how to use ROS 2 command-line tools to inspect the communication happening in your robot system."}),"\n",(0,i.jsx)(s.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(s.h3,{id:"nodes-as-processes",children:"Nodes as Processes"}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.strong,{children:"node"})," in ROS 2 is a process that performs computation. It's the fundamental building block of a ROS program. In Python, nodes are implemented by extending the ",(0,i.jsx)(s.code,{children:"rclpy.node.Node"})," class. Each node can:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Publish data to topics"}),"\n",(0,i.jsx)(s.li,{children:"Subscribe to data from topics"}),"\n",(0,i.jsx)(s.li,{children:"Provide services"}),"\n",(0,i.jsx)(s.li,{children:"Act as a client to services"}),"\n",(0,i.jsx)(s.li,{children:"Execute actions"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Nodes are designed to be modular and independent. This means you can develop, test, and debug each node separately, then combine them to create complex robotic systems. This modularity is crucial for Physical AI systems where different components (perception, reasoning, actuation) might be developed by different teams or even run on different computers."}),"\n",(0,i.jsx)(s.h3,{id:"topics-as-data-streams",children:"Topics as Data Streams"}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.strong,{children:"topic"})," is a named channel through which nodes exchange messages. Topics use a publish-subscribe communication pattern where:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Publishers"})," send messages to a topic"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Subscribers"})," receive messages from a topic"]}),"\n",(0,i.jsx)(s.li,{children:"Multiple publishers can send to the same topic"}),"\n",(0,i.jsx)(s.li,{children:"Multiple subscribers can receive from the same topic"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This decoupled communication means publishers don't need to know about subscribers and vice versa. This loose coupling makes systems more flexible and robust."}),"\n",(0,i.jsx)(s.h3,{id:"publishers-and-subscribers",children:"Publishers and Subscribers"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.strong,{children:"publisher-subscriber"})," pattern is the most common communication method in ROS 2:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Publishers"})," create and send messages to topics"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Subscribers"})," receive messages from topics"]}),"\n",(0,i.jsx)(s.li,{children:"Communication is asynchronous - publishers and subscribers don't need to run simultaneously"}),"\n",(0,i.jsx)(s.li,{children:"Messages are distributed to all subscribers on a topic"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"This pattern is ideal for sensor data distribution, status updates, and other continuous data streams."}),"\n",(0,i.jsx)(s.h3,{id:"message-types-and-structure",children:"Message Types and Structure"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Messages"})," are the data structures that flow between nodes through topics. Each message type has a specific structure defined in a ",(0,i.jsx)(s.code,{children:".msg"})," file. Common built-in message types include:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"std_msgs/msg/String"})," - Simple string messages"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"std_msgs/msg/Int32"})," - 32-bit integer messages"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"geometry_msgs/msg/Twist"})," - Velocity commands for robots"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"sensor_msgs/msg/JointState"})," - Joint position, velocity, and effort information"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Message types are strongly typed, ensuring that nodes exchange compatible data. You can also define custom message types for your specific application needs."}),"\n",(0,i.jsx)(s.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(s.h3,{id:"python-rclpy-publisher-example",children:"Python rclpy Publisher Example"}),"\n",(0,i.jsx)(s.p,{children:"Let's create a simple publisher node that publishes messages to a topic:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"# publisher_member_function.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\n\r\nclass MinimalPublisher(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('minimal_publisher')\r\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = 'Hello World: %d' % self.i\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\r\n        self.i += 1\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    minimal_publisher = MinimalPublisher()\r\n\r\n    rclpy.spin(minimal_publisher)\r\n\r\n    # Destroy the node explicitly\r\n    minimal_publisher.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(s.h3,{id:"python-rclpy-subscriber-example",children:"Python rclpy Subscriber Example"}),"\n",(0,i.jsx)(s.p,{children:"Now let's create a subscriber node that receives messages from the same topic:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"# subscriber_member_function.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\n\r\nclass MinimalSubscriber(Node):\r\n\r\n    def __init__(self):\r\n        super().__init__('minimal_subscriber')\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'topic',\r\n            self.listener_callback,\r\n            10)\r\n        self.subscription  # prevent unused variable warning\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    minimal_subscriber = MinimalSubscriber()\r\n\r\n    rclpy.spin(minimal_subscriber)\r\n\r\n    # Destroy the node explicitly\r\n    minimal_subscriber.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(s.h3,{id:"running-publisher-and-subscriber",children:"Running Publisher and Subscriber"}),"\n",(0,i.jsx)(s.p,{children:"To run these nodes, save them in a ROS 2 package and execute:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Run the publisher"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"ros2 run your_package_name publisher_member_function\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"In a new terminal, run the subscriber"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"ros2 run your_package_name subscriber_member_function\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"custom-message-type-example",children:"Custom Message Type Example"}),"\n",(0,i.jsxs)(s.p,{children:["To create a custom message type, create a file called ",(0,i.jsx)(s.code,{children:"Num.msg"})," in the ",(0,i.jsx)(s.code,{children:"msg/"})," directory of your package:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"int64 num\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Then add the message dependency to your ",(0,i.jsx)(s.code,{children:"package.xml"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:"<depend>builtin_interfaces</depend>\r\n<member_of_group>rosidl_interface_packages</member_of_group>\n"})}),"\n",(0,i.jsxs)(s.p,{children:["And update your ",(0,i.jsx)(s.code,{children:"setup.py"})," to include the message:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"from setuptools import setup\r\nfrom glob import glob\r\nimport os\r\n\r\npackage_name = 'your_package_name'\r\n\r\nsetup(\r\n    # ... other setup parameters ...\r\n    data_files=[\r\n        # ... other data files ...\r\n        (os.path.join('share', package_name), glob('msg/*.msg')),\r\n    ],\r\n    # ... rest of setup ...\r\n)\n"})}),"\n",(0,i.jsx)(s.h3,{id:"topic-introspection-using-cli",children:"Topic Introspection Using CLI"}),"\n",(0,i.jsx)(s.p,{children:"ROS 2 provides powerful command-line tools to inspect topics:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"List all topics"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"ros2 topic list\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Get info about a specific topic"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"ros2 topic info /topic\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Echo messages from a topic"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"ros2 topic echo /topic std_msgs/msg/String\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Publish to a topic directly"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"ros2 topic pub /topic std_msgs/msg/String \"data: 'Hello from CLI'\"\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"ros-graph-visualization",children:"ROS Graph Visualization"}),"\n",(0,i.jsx)(s.p,{children:"Here's a visualization of the publisher-subscriber pattern:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-mermaid",children:"graph LR\r\n    A[Publisher Node] --\x3e|publishes| B((Topic))\r\n    B --\x3e|distributes| C[Subscriber Node 1]\r\n    B --\x3e|distributes| D[Subscriber Node 2]\r\n    B --\x3e|distributes| E[Subscriber Node 3]\r\n\r\n    style A fill:#4CAF50\r\n    style C fill:#2196F3\r\n    style D fill:#2196F3\r\n    style E fill:#2196F3\r\n    style B fill:#FF9800\n"})}),"\n",(0,i.jsx)(s.p,{children:"In this diagram:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Green: Publisher Node sending messages"}),"\n",(0,i.jsx)(s.li,{children:"Orange: Topic channel distributing messages"}),"\n",(0,i.jsx)(s.li,{children:"Blue: Subscriber Nodes receiving messages"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"summary--key-takeaways",children:"Summary & Key Takeaways"}),"\n",(0,i.jsx)(s.p,{children:"In this chapter, you've learned about the fundamental communication patterns in ROS 2:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Nodes"})," are processes that perform computation and serve as the building blocks of ROS 2 systems"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Topics"})," are named channels for asynchronous message passing between nodes"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Publishers"})," send messages to topics, and ",(0,i.jsx)(s.strong,{children:"subscribers"})," receive messages from topics"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Messages"})," are strongly-typed data structures that flow between nodes"]}),"\n",(0,i.jsx)(s.li,{children:"The publish-subscribe pattern enables loose coupling and flexible system design"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["You've also learned how to create publisher and subscriber nodes in Python using ",(0,i.jsx)(s.code,{children:"rclpy"}),", how to define custom message types, and how to use ROS 2 command-line tools for topic introspection."]}),"\n",(0,i.jsx)(s.p,{children:"In the next chapter, we'll explore services and actions, which provide different communication patterns for request-response interactions and long-running tasks respectively. These patterns complement topics and messages to provide a complete communication toolkit for robotics applications."})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,s,n){n.d(s,{R:()=>o,x:()=>a});var r=n(6540);const i={},t=r.createContext(i);function o(e){const s=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);